apiVersion: v1
kind: Service
metadata:
  name: api-server-svc
  labels:
    app: api-server
spec:
  selector:
    app: api-server
  ports:
  - name: http
    port: 8000
    protocol: TCP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-server-cm
  labels:
    app: api-server
data:
  requirements.txt: |
    fastapi==0.75.0
    pydantic==1.9.0
    uvicorn==0.17.6
    nats-py==2.1.0
  __init__.py: |
  publisher.py: |
      import nats
      from nats.errors import TimeoutError
      
      
      class Publisher:
          def __init__(self, host):
              self.host = host
              self.client = None
              self.jetstream = None
      
          async def connect(self):
              try:
                  self.client = await nats.connect(self.host)
                  self.jetstream = self.client.jetstream()
              except TimeoutError:
                  return False
      
          async def publish(
                  self,
                  subject: str,
                  payload: bytes,
                  timeout: float,
                  stream: str,
                  headers: dict = None
          ):
              # check jetstream connection
              if self.jetstream is None:
                  streamInfo = await self.connect()
                  if streamInfo is False:
                      return False
      
              # publish the message
              try:
                  return await self.jetstream.publish(subject, payload, timeout, stream, headers)
              except TimeoutError:
                  return False
  main.py: |
      """
      The API server handle payload agnostic writes to the Nats Jetstream Server
      """
      
      from fastapi import FastAPI
      import pickle
      from publisher import Publisher
      from templates import schema
      
      HOST = '{address}:{port}'
      app = FastAPI()
      pub = Publisher(HOST.format(address='10.99.148.136', port='4222'))
      
      
      async def publish(data, subject, timeout, stream):
          payload = pickle.dumps(data.dict())
          ack = await pub.publish(subject, payload, timeout, stream)
          return ack
      
      
      @app.get('/')
      async def root():
          return "api server"
      
      @app.post('/PlaceInfoModel')
      async def receivePlaceInfo(data: schema.PlaceInfoModel):
          return await publish(data, 'scraped', 2.0, 'data')
      
      
      @app.post('/ReviewInfoModel')
      async def receiveReviewInfo(data: schema.ReviewInfoModel):
          return await publish(data, 'scraped', 2.0, 'data')
      
      
      @app.post('/UserInfoModel')
      async def receiveUserInfo(data: schema.UserInfoModel):
          return await publish(data, 'scraped', 2.0, 'data')
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server
  labels:
    app: api-server
spec:
  selector:
    matchLabels:
      app: api-server
  replicas: 1
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: api-server
    spec:
      volumes:
      - name: api-server-volume
        configMap:
          name: api-server-cm
      containers:
      - name: api-server
        image: python:3.8
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 8000
        - name: tcp-client
          containerPort: 4222
        volumeMounts:
        - name: api-server-volume
          mountPath: /app
        command:
        - "/bin/bash"
        - "-c"
        - "pip install -r /app/requirements.txt;
          uvicorn main:app --app-dir /app --proxy-headers --host 0.0.0.0 --port 8000"
      terminationGracePeriodSeconds: 30